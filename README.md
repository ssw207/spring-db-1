# JDBC 등장
- 어플리케이션이 DB에 접근하려면 TCP/IP 커넥션은 연결하고 SQL을 전송하고 응답결과를 받는 과정을 개발자가 직접 개발해야함
- DB벤더사 마다 이런 방식이 달라 DB가 변경되면 너무 많은 부분이 변경되야하며 사용법도  새로 배워야하는 불편함이 있었음
- 자바 어플리케이션과 DB연결을 표준화한 JDBC가 등장
- 벤더사는 JDBC인터페이스를 구연한 라이브러리를 제공하며 이걸 JDBC드라이버라고 한다.
- 자바 어플리케이션 개발자는 JDBC 인터페이스만 알면 벤더사와 상관없이 사용가능하게됨
- 하지만 SQL은 벤더사마다 상이하기 떄문에 DB가 교체되는경우 JDBC로 클라이언트 코드는 변경할 필요가 없지만 SQL를 변경해야하는 이슈가 발생하게 된다.

# JDBC와 데이터 접근기술
- SQL Mapper
- ORM

# DataSource
- - 커넥션을 만들게 되면 로직처리시간 + 커넥션 생성하는 시간 = 응답시간이 되어 응닥 속도가 느려지게 된다.
- 사용자 요청이 들어올때 넥션을 미리 만들어놓고 사용자 요청이 올때 이 커넥션을 꺼내 쓰고 다쓰면 커넥션을 반환 하는 방식으로 구현된것이 커넥션풀이다
- DataSource는 JDBC의 DB커넥션풀 인터페이스이다. 벤더사마다 이 인터페이스를 구현한 커넥션풀을 사용하기 때문에 벤더사가 바뀌어도 구현체만 바꿔주면 된다.
- DataSource는 설정과 사용로직이 분리되어있어 최초 객체 생성시 관련 설정정보를 입력하고 사용할때는 입력하지 않는다.

---

# 트렌젝션 이해
- 일련의 작업들이 모인 처리의 단위
- ACID
  - 원자성 : 모두 성공하고나 모두 실패해야한다
  - 일관성 : 트렌젝션이후 데이터베이스의 상태는 일관되야한다 ex) 무결성 조건 만족
  - 격리성 : 동시에 같은 데이터를 수정하지 못하도록 격리 (격리수준)
  - 지속성 : 트랜젝션이 성공하면 결과가 기록되야함
- db는 기본적으로 auto commit true이다. auto 트랜젝션 시작은 auto commit false를 뜻한다 
- 트렌젝션을 사용하라면 같은 세션이 유지되야한다.(= 같은 커넥션을 유지해야한다)

# 트렌젝션 격리수준
- READ UNCOMMITTED : 커밋 안된것도 읽는다
- READ COMMITTED (기본) : 커밋된것만 읽는다
- REPEATABLE READ : 반복 가능한 읽기
- SERIALIZABLE : 직렬화 가능

# 데이터베이스 연결과주와 DB세션
- db와 커넥션을 맺으면 db세션이 생성된다

# DB락
- 특정 데이터를 두개의 세션에서 동시에 변경하려고 할때 먼저 데이터를 변경한 세션이 커밋될때 까지 두번째 세션의 접근을 막지 않으면 트렌젝션의 원자성이 깨지게 된다
- 원자성을 지키기위해 먼저 데이터를 변경하려는 세션은 락을획득해 다른 세션에서 변경하지 못하게한다. 락을 획득후 락획득시간까지 커밋하지 않으면 에러가 발생한다.
    - 트렌젝션 순서
      1. 트렌젝션시작 
      2. 락 획득
      3. update 쿼리실행 
      4. 커밋
      5. 락 반납 
## DB락 - 조회
- 일반적으로 조회시 락을 걸지 않는다.
- 하지만 정산등 조회한 결과를 계산할때 조회한 데이터가 변경되면 계산이 틀어질수 있다. 이런경우 조회한 데이터를 변경하지 못하도록 락이 필요하다 
- 데이터를 조회시 락을 걸려면 `select for update` 구문을 사용하면됨

# Spring 트렌젝션 매니저
- 서비스 레이어는 특정기술에 종속되지 않고 순수 비즈니스 로직만 있어야한다 (특정기술에 종속적이지 않아야 기술이 변경되더라도 서비스레이어는 변경되지 않는다.)
- 서비스 레이어에서 DataSource로부터 직접 트렌젝션을 시작하면 서비스레이어가 JDBC에 종속성이 생긴다. 이렇게 되면 차후 DB접속 기술을 JPA등 으로 변경하게 되면 서비스레이어의 트렌젝선 로직을 모두 수정해야하는 문제가 발생한다.  
- JDBC, JPA등 데이터베이스 접속 기술에 따라 트렌젝션 코드가 다르기 때문에 Spring에서는 트렌젝션 매니저를 통해 데이터접속을 추상화한다.

## 트렌젝션 매니저 동작
  1. PlatformTransactionManager.getTransaction() 을 호출
  2. 주입받은 DataSource에서 DB 커넥션 생성
  3. auto commit false로 트렌젝션 시작
  4. 커넥션을 트렌젝션 동기화 매니저에 보관 (동일한 트렌젝션의 메소드에서 같은 커넥션을 사용하기 위해 따로 저장한다.)
  5. 트렌젝션 동기화 매니저는 쓰래드로컬에 커넥션을 보관 (멀티 쓰레드 환경에서 동시성 문제를 피하기위해 사용)
  6. 비즈니스 로직 실행. DB접속이 필요한경우 DataSourceUtils.getConnection()을 사용해 트렌젝션 동기화 매니저에 저장된 커넥션을 사용하고 트렌젝션을 유지한다
  7. 획득한 커넥션을 사용해 SQL을 DB로 전달해 실행 
  8. 비즈니스 로직이 끝나고 트렌젝션 종료한다 (커밋, 롤백)
  9. 트렌젝션을 종료하기 위해 트렌젝션 동기화 매니저에서 커넥션을 가져온다.
  10. 커넥션을 통해 데이터베이스의 트렌젝션을 커밋 or 롤백한다.
  11. 전체 리소스 정리
      - 트렌젝션 동기화 매니저에 쓰레드로컬 정리
      - auto commit true로 변경
      - 커넥션 종료 (커넥션 풀을 사용하면 풀에 커넥션이 반환됨)
  
# 트렌젝선 로직 반복문제 해결
- 서비스레이어에 반복되는 트렌젝션은 템플릿 콜백패턴을 구현한 JdbcTemplate을 사용해 해결한다.

# 데이터 접속기술과 예외문제
- JDBC의 에러는 기본적으로 checked exception인 sql exception을 던지게 되어있다.
- checked 익셉션은 반드시 잡아서 처리해야되기 때문에 서비스 레이어에서 throw 로 던지면 SQLException이 서비스 레이어에 사용되어 서비스 레이어에 JDBC 종속성이 생겨난다.
- 서비스 레이어에 종속성을 제거하기 위해서는 SqlException을 try catch로 잡아 RuntimeException으로 바꿔서 던지면된다.
- DB에서 중복키 예외등 특정 예외가 발생하면 SqlException에 오류코드를 던져 준다. 
- 이 오류코드를 잡아 서비스 레이어에 키 중복 예외가 발생하면 키를 재생성해 다시 insert 처리하는등의 작업이 가능하다.
- 하지만 DB마다 에러코드가 모두 다르기때문에 이런식으로 처리하게 되면 DB를 바꾸게되면 모든 에러코드를 바꿔야하는 이슈가 발생한다.
- 스프링에서는 이런 DB에러를 사전에 XML에 DB별로 저장해 놓고 DB별 에러코드에 따라 예외를 얻을수 있도록 추상화 되어있다.
- 서비스 레이어에서는 Spring이 추상화한 예외 클리스를 사용하면 DB 종속성 없이 DB예외 처리를 할수 있다.