#  JDBC의 등장
- 어플리케이션이 DB에 접근하려면 TCP/IP 커넥션은 연결하고 SQL을 전송하고 응답결과를 받는 과정을 개발자가 직접 개발해야함 
- DB벤더사 마다 이런 방식이 달라 DB가 변경되면 너무 많은 부분이 변경되야하며 사용법도  새로 배워야하는 불편함이 있었음
- 자바 어플리케이션과 DB연결을 표준화한 JDBC가 등장
- 벤더사는 JDBC인터페이스를 구연한 라이브러리를 제공하며 이걸 JDBC드라이버라고 한다.
- 자바 어플리케이션 개발자는 JDBC 인터페이스만 알면 벤더사와 상관없이 사용가능하게됨
- 하지만 SQL은 벤더사마다 상이하기 떄문에 DB가 교체되는경우 JDBC로 클라이언트 코드는 변경할 필요가 없지만 SQL를 변경해야하는 이슈가 발생하게 된다.

# JDBC와 데이터 접근기술
- SQL Mapper
- ORM

# DataSource
- 사용자 요청이 들어올때 커넥션을 만들게 되면 로직처리시간 + 커넥션 생성하는 시간 = 응답시간이 되어 응닥 속도가 느려지게 된다.
- 그래서 어플리케이션 구동시 커넥션을 미리 만들어놓고 사용자 요청이 올때 이 커넥션을 꺼내 쓰고 다쓰면 커넥션을 반환 하는 방식으로 구현된것이 커넥션풀이다
- DataSource는 JDBC의 DB커넥션풀 인터페이스이다. 벤더사마다 이 인터페이스를 구현한 커넥션풀을 사용하기 때문에 벤더사가 바뀌어도 구현체만 바꿔주면 된다.
- DataSource는 설정과 사용로직이 분리되어있어 최초 객체 생성시 관련 설정정보를 입력하고 사용할때는 입력하지 않는다.

---

# 트렌젝션 이해
- 일련의 작업들이 모인 처리의 단위
- ACID
  - 원자성 : 모두 성공하고나 모두 실패해야한다
  - 일관성 : 트렌젝션이후 데이터베이스의 상태는 일관되야한다 ex) 무결성 조건 만족
  - 격리성 : 동시에 같은 데이터를 수정하지 못하도록 격리 (격리수준)
  - 지속성 : 트랜젝션이 성공하면 결과가 기록되야함
- db는 기본적으로 auto commit true이다. auto 트랜젝션 시작은 auto commit false를 뜻한다 
- 트렌젝션을 사용하라면 같은 세션이 유지되야한다.(= 같은 커넥션을 유지해야한다)

# 트렌젝션 격리수준
- READ UNCOMMITTED : 커밋 안된것도 읽는다
- READ COMMITTED (기본) : 커밋된것만 읽는다
- REPEATABLE READ : 반복 가능한 읽기
- SERIALIZABLE : 직렬화 가능

# 데이터베이스 연결과주와 DB세션
- db와 커넥션을 맺으면 db세션이 생성된다

# DB락
- 특정 데이터를 두개의 세션에서 동시에 변경하려고 할때 먼저 데이터를 변경한 세션이 커밋될때 까지 두번째 세션의 접근을 막지 않으면 트렌젝션의 원자성이 깨지게 된다
- 원자성을 지키기위해 먼저 데이터를 변경하려는 세션은 락을획득해 다른 세션에서 변경하지 못하게한다. 락을 획득후 락획득시간까지 커밋하지 않으면 에러가 발생한다.
    - 트렌젝션 순서
      1. 트렌젝션시작 
      2. 락 획득
      3. update 쿼리실행 
      4. 커밋
      5. 락 반납 
## DB락 - 조회
- 일반적으로 조회시 락을 걸지 않는다.
- 하지만 정산등 조회한 결과를 계산할때 조회한 데이터가 변경되면 계산이 틀어질수 있다. 이런경우 조회한 데이터를 변경하지 못하도록 락이 필요하다 
- 데이터를 조회시 락을 걸려면 `select for update` 구문을 사용하면됨